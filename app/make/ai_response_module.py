import os
import openai
from openai import OpenAI
from db.db_ops import db_manager
from config import OPENAI_API_KEY
# Create OpenAI client with API key (replace or use environment variable)
client = openai.OpenAI(api_key=OPENAI_API_KEY)
import csv
import requests
import smtplib
from email.message import EmailMessage
from email.mime.multipart import MIMEMultipart
from email.mime.text import MIMEText
from datetime import datetime, timedelta
from flask import Flask
EMAIL_ADDRESS = 'shibla@taippa.com'
EMAIL_PASSWORD = 'rkecttakcyajughv'
TO_EMAIL = 'shiblashilu@gmail.com'
CC_EMAILS = ['shilusaifshilu@gmail.com', 'sravan@taippa.com']

def send_linkedin_html_email(lead):
    msg = MIMEMultipart("alternative")
    msg['Subject'] = f'New LinkedIn Response - {lead.get("campaign_name", "Guideline Middle East")}'
    msg['From'] = EMAIL_ADDRESS
    msg['To'] = TO_EMAIL
    msg['Cc'] = ', '.join(CC_EMAILS)

    html_content = f"""
    <p>Hi Mag,</p> 

    <p>We've received a response for the <strong>"{lead.get("campaign_name", "Guideline Middle East")}"</strong> campaign via LinkedIn.</p>

    <h4>Lead Details:</h4>
    <ul>
      <li><strong>Name:</strong> {lead.get("full_name", "N/A")}</li>
      <li><strong>LinkedIn:</strong> <a href="{lead.get("linkedin_profile_url", "#")}">{lead.get("linkedin_profile_url", "N/A")}</a></li>
      <li><strong>Message:</strong> "{lead.get("response_message", "No message provided")}"</li>
    </ul>

    <br>
    This is an automated message generated by our lead capture system. For any questions or follow-up actions, please reach out to the team directly.
    <br><br>
    <p>Best,<br>Team Generate</p>
    """

    msg.attach(MIMEText(html_content, "html"))
    recipients = [TO_EMAIL] + CC_EMAILS

    try:
        with smtplib.SMTP_SSL('smtp.gmail.com', 465) as smtp:
            smtp.login(EMAIL_ADDRESS, EMAIL_PASSWORD)
            smtp.send_message(msg, to_addrs=recipients)
        print("‚úÖ LinkedIn lead response email sent successfully.")
    except Exception as e:
        print(f"‚ùå Email sending failed: {e}")

def classify_linkedin_message(message_text):
    system_prompt = """You are an AI agent designed to analyze LinkedIn messages from leads and classify them as either "Positive" or "Negative".

Classification Criteria:

Positive:
- Agreement or enthusiasm
- Requests for more details or next steps
- Expressions of approval

Negative:
- Direct rejections or disagreements
- Requests to be removed from communication
- Neutral responses that do not show interest

Rules:
- If the message shows any level of interest, classify it as "Positive."
- If the message is neutral or negative in tone, classify it as "Negative."
- Do not classify ambiguous messages as "Positive" unless there is a clear intent to engage.

Output:
Return only one of the following labels:
1) Positive
2) Negative
"""

    user_prompt = f'This is the LinkedIn message text received from the lead: "{message_text}"\n\nClassify this message based on the criteria.'

    response = client.chat.completions.create(
        model="gpt-4",
        messages=[
            {"role": "system", "content": system_prompt},
            {"role": "user", "content": user_prompt}
        ],
        temperature=0
    )

    return response.choices[0].message.content.strip()

# # Example usage
# if __name__ == "__main__":
#     test_message = "I‚Äôm not interested at this time, but thanks for reaching out"
#     result = classify_linkedin_message(test_message)
#     print("Classification:", result)

def linkedin_ai_response_tacker(data):
    try:
        
        sentiment = classify_linkedin_message(data["response_message"])
        print("Classification:", sentiment)
        # data = {
        #     "thread_id": "influencer_marketing_60d2165a8530680001f38bd8",
        #     "campaign_name": "influencer_marketing",
        #     "linkedin_profile_url": "http://www.linkedin.com/in/pj-leimgruber",
        #     "full_name": "Magda Houalla",
        #     "email": "magdaoualla@gmail.com",
        #     "picture": "https://media.licdn.com/dms/image/v2/D5603AQHeEZ4rcWOAXg/profile-displayphoto-shrink_200_200/profile-displayphoto-shrink_200_200/0/1728920716356?e=1750291200&v=beta&t=Xhuu3diZgNeydUQs0OE2zPQOwH5L3321gUHQVYSuwBo"
        # }
        table_name = "leadsin_response_linkedin"
        column_name = "campaign_name"
        unique_value = "linkedin_profile_url"
        duplicate_records = db_manager.get_records_with_filter(
            table_name="leadsin_response_linkedin",
            cols_list=["linkedin_profile_url","campaign_name" ],
            col_values=[data["linkedin_profile_url"], data["campaign_name"]],
            limit=1
        )

        if duplicate_records:
            if isinstance(duplicate_records, dict):  
                duplicate_records = [duplicate_records]

            print(f"‚ö†Ô∏è Duplicate found for {data['linkedin_profile_url']}")
            for record in duplicate_records:
                print(f"üîÅ Duplicated Record: {record}")
                print(f"üßµ thread_id: {record.get('thread_id')}")
        else:
            if sentiment == "Positive":        
                #i need to add gmail module 
                new_lead = {
                    "campaign_name": data["campaign_name"],
                    "full_name": data["full_name"],
                    "linkedin_profile_url": data["linkedin_profile_url"],
                    "response_message": data["response_message"]
                }
                send_linkedin_html_email(new_lead)      
                cols_list = ['campaign_name', 'linkedin_profile_url']
                # col_values = ['influencer_marketing', 'http://www.linkedin.com/in/carlybrower']
                leadsrecords = db_manager.get_records_with_filter("linkedin_leads", cols_list, col_values, limit=1)
                if isinstance(leadsrecords, dict):
                    leadsrecords = [leadsrecords]
                print(f"üî¢ Matching Record Count in linkedin_leads: {len(leadsrecords)}")

                if len(leadsrecords) == 1:
                    print(f"üõ† Only one matching record found in linkedin_leads. Updating status to Positive.")
                    if leadsrecords:
                        record = leadsrecords[0]  # Pick the first one if available
                        db_manager.update_single_field(
                            table_name="linkedin_leads",
                            column_name='status',
                            column_value="Responded: Interested",
                            primary_key_col='thread_id',
                            primary_key_value=record['thread_id']
                        )
                        print(f"‚úÖ Record updated status to {sentiment} successfully.")
                        data[sentiment]= "Positive"
                        db_manager.insert_data(table_name, data)
                        print("Completed linkedin response table updation")  
        if sentiment == "Negative":
            cols_list = ['campaign_name', 'linkedin_profile_url']
            # col_values = ['influencer_marketing', 'http://www.linkedin.com/in/carlybrower']
            col_values = [data["campaign_name"], data["linkedin_profile_url"]]
            leadsrecords = db_manager.get_records_with_filter("linkedin_leads", cols_list, col_values, limit=1)
            if isinstance(leadsrecords, dict):
                leadsrecords = [leadsrecords]
            print(f"üî¢ Matching Record Count in linkedin_leads: {len(leadsrecords)}")

            if len(leadsrecords) == 1:
                print(f"üõ† Only one matching record found in linkedin_leads. Updating status to Negative.")
                if leadsrecords:
                    record = leadsrecords[0]  # Pick the first one if available
                    db_manager.update_single_field(
                        table_name="linkedin_leads",
                        column_name='status',
                        column_value="Responded: Not Interested",
                        primary_key_col='thread_id',
                        primary_key_value=record['thread_id']
                    )
                    print(f"‚úÖ Record updated status to {sentiment} successfully.")
                    data[sentiment]= "Negative"
                    db_manager.insert_data(table_name, data)
                    print("Completed linkedin response table updation")             

    except Exception as e:
        print(f"‚ùå Error during DB test: {e}")
        raise
